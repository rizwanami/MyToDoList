{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 HelveticaNeue;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red180\green0\blue98;\red255\green255\blue255;
\red0\green0\blue0;\red77\green0\blue158;\red186\green0\blue17;\red31\green36\blue45;\red255\green255\blue255;
\red224\green239\blue242;\red13\green100\blue126;\red92\green38\blue153;\red48\green111\blue121;\red68\green137\blue147;
\red46\green13\blue110;\red0\green0\blue255;\red0\green0\blue0;\red32\green60\blue63;\red0\green11\blue255;
\red29\green133\blue25;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\csgenericrgb\c70682\c0\c38264;\csgenericrgb\c100000\c100000\c100000;
\csgenericrgb\c0\c0\c0;\csgenericrgb\c30278\c0\c61966;\csgenericrgb\c72768\c0\c6662;\cssrgb\c16078\c18824\c23137;\cssrgb\c100000\c100000\c100000;
\cssrgb\c90196\c94902\c96078;\cssrgb\c0\c46667\c56863;\csgenericrgb\c35900\c14900\c60100;\csgenericrgb\c18769\c43699\c47289;\csgenericrgb\c26518\c53646\c57619;
\csgenericrgb\c18100\c5200\c43100;\cssrgb\c1680\c19835\c100000;\cssrgb\c0\c0\c0;\csgenericrgb\c12359\c23384\c24757;\csgenericrgb\c0\c4459\c99822;
\csgenericrgb\c11489\c52197\c9852;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 \
Lesson section 18 lesson 218 Creating a Texfield adn AlertView insie the addNewItem Button:\
1) we need to pop a textfield when we pressed newAddItem button so we create a AlertView inside the action and we craeted an Textfield.\
2) Action in alert end with closure where we save whaever user enter in texfield and click done.\
3) So we added the action and then present the view controller that is AlertView controller\
In This we use tableview view controller  we use an array of Item to populate table view \
the app then used NSDeafaultv to save the user enter item in the array and then it tableview relaod to populate the array the we retrive the data from user default store , but intiall our array was hard coded and has only string . But when we create an model class for item in the array which was has two property and we tried to append the array withe class we find fatal error because userDefault can only handle sinple data like strin, Int and Boolean.\
\
Then we used Plist and coder to store this data. so we encode data and the decoded it and retrive it from plist. But if we used this method it takes the memoery of our device and app become slow. \
So for storing big data we used Core data \
\
It also discuss differnt kind of storage we can use\
\
In Core data section we learn how to add core data file and set up the app for core data. WE created contex and save the context, so our app was able to save the data \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ul \ulc0 Section 18 lesson 230\ulnone  :\
1) Here we learn how to add core data in any exiting app.\
2) Here will add core data file to our app\
3) In app delegate which without core data will we copy the code which needed and paste to it from func applicatin will termiante to last and then delete application willTerminate and also \cf2 import coredata,  then the change the name of coredata file\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\b0\fs34 \cf3 \cb4 let\cf5  container = \cf6 NSPersistentContainer\cf5 (name: \cf7 "DataModel"\cf5 )\
Create the entity and we selected it type as class as class Defintion which need less effeort, there are three option in class selection 1) Mannual or None which least used, 2) Class Debnition which is need less effort, 3) Category Extension 
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
because sometimes developers might want to add in some custom code. \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 So if we have a look back at the swift file where X code automatically generated this class declaration\cb1 \
\pard\pardeftab720\sl500\sa210\partightenfactor0
\cf8 \cb10 for item entity then you'll see that aren't I an entity inherits or subclasses and as managed objects\cb1 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \cb9 and manage objects are basically core data model objects.\cb1  \cb9 It's similar but not quite the same as our standard objects.\cb1  \cb9 But by subclassing and manage objects it allows us to manage this class using core data.\cb1 \
\cb9 So if you do create your own custom classes and you go for the option of category/extension a third type in Class selection in Context \cb1  \cb9 then you also want to inherit from an s managed objects in order for your code to work.\cb1 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf11 \cb9 \ul \ulc11 So now that we've seen the automatic code that gets generated behind the scenes.\
\cb1 Now we look the core data code in App Delagate class \
In this we got global variable called \cb10  persistent container and also a method could save context.\
The persistene controlle we craete is Lazy\
\cf8 \cb9 \ulnone So inside this lazy variable we're creating a N.S. persistent container.\cb1  \cb9 And this is basically where we are going to store all of our data.And even though it's called and as persistent container which sounds kind of fancy it's actually going\cb1  \cf11 \cb9 \ul to be a sequel live database.\
\cf8 \ulnone then we create a constant called container that sets up this new persistent container with the name of our data\cb1 \
\cb9 model.\cb1  \cf11 \cb9 \ul And these two have to match. \cf8 \ulnone So that all the behind the scenes setup and the relationships gets created properly and then we're going\cb1  \cb9 to load up this persistent store and we're going to log if there were any errors.\cb1 \
\cb9 But if there weren't any errors then we're going to return the container that we loaded up and we're\cb1 \
\cb9 going to set it as the value of this lazy variable called persistent container and we'll be able to \cf11 \ul access it inside other classes in order to persist and save our data into our sequel like database.\
\cf8 \cb1 \ulnone \
\cf11 \cb9 \ul 2) SaveContext: \cf8 \ulnone Now this is other help a method could save context and this just provide some support to saving our\cb1 \
\cb9 data when our application gets terminated.\cb1  \cb9 But you see this thing called a context and we're going to look into the context a lot more later on.\cb1  \cb9 But essentially the context is an area where you can change and update your data so you can undo and\cb1  \cb9 redo until you're happy with your data and then you can save the data that's in your contacts or your\cb1  \cf11 \cb9 \ul temporary area to the container which is for permanent storage.\
\
 SECTION 28 lesson How save data in COreData(CRUD)(create, read, update and delete:\
\cf8 \ulnone 1) In ToDoListViewCntroller  we have to create our an object which refer to entity Item.  To do this we have get the context first which in persistent container which is in app delegate.The app delaget Class we have in our app is Blue print and we get the object from this blue print\
To get acces to app delegate  we have to use the singleton UIApplication and throgh this UIApplication we would shared the delegate class which is appa delegate. \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \kerning1\expnd0\expndtw0 let\cf5  context = (\cf6 UIApplication\cf5 .\cf12 shared\cf5 .\cf12 delegate\cf5  \cf3 as\cf5 ! \cf13 AppDelegate\cf5 ).\cf14 persistentContainer\cf5 .\cf12 viewContext
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \
And inside this shared UI application object is something called delegate and this is the delegate of\cb1 \
\cb9 the app object.\cb1 \
\cb9 Alternatively known as the app delegate.\cb1 \
\pard\pardeftab720\sl500\sa210\partightenfactor0
\cf11 \cb10 \ul And we're going to downcast it as our class delegate.\cb1 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \cb9 \ulnone So let's just give you a bit more space to see that whole line as it is.\cb1 \
\cb9 So we're tapping into the UI Application class.\cb1 \
\cb9 We're getting the shared singleton object which corresponds to the current app as an object tapping\cb1 \
\cb9 into its delegate which has the data type of an optional UI application delegate.\cb1 \
\cb9 We're casting it into our class app delegate because they both inherit from the same superclass.\cb1 \
\cb9 You want application delegate.\cb1 \
\cb9 This is perfectly valid and we now have access to our app delegate as an object.\cb1 \
\cb9 So we're able to tap into its property code persistent container and we're going to grab the view context\cb1 \
\cf11 \cb9 \ul of that persistent container so we can now save our context is this context.\cb1 \
\cf8 \cb9 \ulnone \
2)  Then we created our item in addButton \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \kerning1\expnd0\expndtw0 let\cf5  newItem = \cf13 Item\cf5 (context: \cf3 self\cf5 .\cf14 context\cf5 )
\f2\fs30 \cf11 \cb1 \expnd0\expndtw0\kerning0
\ul \
\
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \cb9 \ulnone \
3) we also chanege the saveItem :\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \kerning1\expnd0\expndtw0 try\cf5  \cf14 context\cf5 .\cf15 save\cf5 ()
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 we are saving it int context\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0  4) Imort coreData\
5) We also added over another attribute of Item entity in addButton becuase this attribute is not optional and it will give as an error could not get compltetd because the "done" attribute is nil\
So we have add this in our "addItem" action Button\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f2\fs30 \cf11 \cb1 \expnd0\expndtw0\kerning0
\ul \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf11 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf16 \ulc16 Section 18 Lesson 232 : How to view Your SQLite Backend For CoreData:\cf11 \ulc11 \
Here we use print func to print our path to place where core data is saving our data\
Then we download datum Developer tool from app store to read data in our app. We also delete some data directly fro Datum .\
\cf16 \ulc16 Section 18 Lesson 233 : Core Data Fundamental  
\b \cf0 \kerning1\expnd0\expndtw0 \ulnone Watch The Video for Better Undersstanding.
\b0 \cf16 \expnd0\expndtw0\kerning0
\ul \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf17 \ulnone 1) Object Oriented Programming; Class   Property    \
 2) Coredata: 				Entity 	Attribute \
 3) Database : 				Table ,	Field\ul \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf16 Section 18 Lesson 235 : Update Data fwith coreadata Update(CRUD)\cf17 	:\
Watch video				\cf11 \ulc11 \
\cf16 \ulc16 Section 18 Lesson 236 :  Removing Data from Core Data, Delete(CRUD):\

\b \cf0 \kerning1\expnd0\expndtw0 \ulnone we have delete from context, In tableView Delegate Method didSelect the row we can cotext.delete and the do contex.save, we can also delete from item we are storing it but we have to delte it from context first then from our object we holdin that like array if we remove it from array first then try to delete from context we will get the fatal error or end up deleting item at  some other poston because the position for item in array would change since we remove it from the array first. \
context.delete \
array.remove\
contex.save\

\b0 \cf16 \expnd0\expndtw0\kerning0
\ul Section 18 Lesson 237 :How to implement a UISearch Bar and Querying with  coreadata :\
1) we are going to implement very simple search bar; \cf8 \cb9 \ulnone But the one that we want is the search bar not the search bar and search display control them because\cb1 \
\pard\pardeftab720\sl500\sa210\partightenfactor0
\cf8 \cb10 2) In viewcontrolle UISerach Bar delegate 3) Make outlet for searchBar 4) Inside viewDidLoad make delegate for it or if you dont want code in view did load we can directly make delegate in storyBoard\
5) we will use this method \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0   \cf3 func\cf5  searchBarSearchButtonClicked(\cf3 _\cf5  searchBar: \cf6 UISearchBar\cf5 ) \{\}\
6) we made an extension of this file and put the search bar in it so this way our code are not crampelled and it is each to read also\
\cf3 extension\cf5  \cf13 ToDoListViewController\cf5  : \cf12 UISearchBarDelegate\cf5  \{\
and also in MVC pattern our c file became very massive and gigantic slowly, so if you modulize then by using extension it will easy for debugging. Rule of thumb whenevr you use a protocol method grouped it in the extension. \
7) 
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
So inside our To Do List View Controller extension where we are extending the functionality with a search\cb1 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \cb9 bar and some search bar methods we've got this delegate method which is going to be triggered once the \cb10 user presses the search button on the search bar.\cb1  \cb9 So this is a good point for us to query our database and try to get back the results that the user is\cb1  \cb9 searching for.\cb1  \cb9 So as always in order to read from the context we always have to create a request and we have to declare\cb1  \cb9 the request data type.\cb1  \cb9 So in this fetch request and it's going to return an array of items and we're going to set this to equal\cb1  \cb9 item dot that's request.\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \kerning1\expnd0\expndtw0 let\cf5  request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 ()
\f2\fs30 \cf8 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \cb9 Now the next step is we have to specify what is going to be our filter right what is going to be our\cb1  \cb9 query.And we do that using soSo in order to query objects using Core data we need to use something called an end as predicate so\cb1 \
\cb9 we can say for example let predicate equals and as predicate and that we're going to initialize it using\cb1  \cb9 a format.\cb1  \cb9 So the format as you can see from the placeholder takes a string and the string is a little bit scary\cb1  \cb9 because you're now typing in free text and in our case what we would do is we would say title we're\cb1  \cb10 going to look at the title attribute of each of our items in item array.\cb1  \cb9 And we're going to check that it contains a value.\cb1  \cb9 So this is the argument that we're going to substitute into this percentage sign.\cb1 \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0  request.\cf12 predicate\cf5  = \cf6 NSPredicate\cf5 (format: \cf7 "title CONTAINS[cd] %@"\cf5 , searchBar.\cf12 text\cf5 !)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
And so when we hit the search button then whatever we have entered inside the search bar at that time\cb1  \cb9 point is going to be passed in to this method into this part and replacing this percentage sign.So then our query becomes for all the items in the item array look for the ones where the title of the item contain this text we typed in search bar. And also we use 
\b \cf0 \cb1 \kerning1\expnd0\expndtw0 [cd] 
\b0 which mean our code is insensitive to diacritic and case(like upper and lower case)\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0
\cf8 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \cb9 The above code for NSPredicate look familir to people who know objective C,  reason is because a predicate is basically a foundation class that specifies how data should be fetched or filtered essentially it is a query language \
There is cheatsheet on realm website because they also use NSPredicate for querying.  \
In the above query we use string and make sure our item in array "
\b \cf0 \cb1 \kerning1\expnd0\expndtw0 contain" t
\b0 \cf8 \cb9 \expnd0\expndtw0\kerning0
hat string\
\cb1 There is an article NSPredicate  written by  \cf0 \kerning1\expnd0\expndtw0 \shad\shadx60\shady-60\shadr0\shado85 \shadc5 Matt Thompson.\cf8 \expnd0\expndtw0\kerning0
\shad0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf16 \ul  \cf0 \kerning1\expnd0\expndtw0 \ulnone 8) Now we are going to add predicate part in our requet\
request.predicate = presicate\
9) Then we will sort our request in sort Descriptor.\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4  request.\cf12 sortDescriptors\cf5  = [\cf6 NSSortDescriptor\cf5 (key: \cf7 "title"\cf5 , ascending: \cf3 true\cf5 )]\
use loadItem funtion\
Watch The Video \
10) How use external and internal parameter.\
11) How apply default parameter\
\cf3 func\cf5  loadItems(with request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 ())\
The above code request is NSFetchRequest but if you dont put any fetch request the default value is \cf13 Item\cf5 .\cf18 fetchRequest\cf5 () also the parameter has an external and internal paraemeter\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f2\fs30 \cf0 \cb1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf16 \expnd0\expndtw0\kerning0
\ul \
\pard\pardeftab720\sl340\sa210\partightenfactor0

\f0\b\fs36 \cf0 \kerning1\expnd0\expndtw0 \ulnone In this we will load all the data.Here we created we created a function 'loadData' . In the loadData we crated an \
\pard\pardeftab720\sl340\sa210\partightenfactor0

\f2\b0\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
But instead we're going to create a new constant called request and we're going to specify it's data\cb1 \
\cb9 type as an s fetch request that is going to fetch results in the form of items.\cb1 \
\cb9 So in swift there's very few cases where you actually need to specify the data type.\cb1 \
\cb9 In most cases you specify the data type because it helps you with the programmer or people on your team\cb1 \
\cb9 to be able to easily see what is going on in your code.\cb1 \
\cb9 But in the majority of cases Swift is clever enough to figure out what is the data type just based on\cb1  \cb9 the value that you give it.\cb1 \
\cb9 But in this case it's a little bit different.\cb1  \cb9 You actually have to specify the data type. If you dont specify data type the xcode will throw an error that ambiguos error whiel performing fetchrequest\cb1 \
\cb9 And most importantly the entity that you're trying to request.\cb1 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf11 \cb9 \ul \ulc11 let request : NSFetchrequet<Item>\
\cf8 \ulnone And as your quest that's going to fetch a whole bunch of items and then we're going to tap into our\cb1  \cb10 item class or item entity and we're going to make a new fecche request.\
\cf11 \cb9 \ul let request : NSFetchrequet<Item> = Item.fetchrequest\
\
\cf8 \cb1 \ulnone  \cb9 And of course as always our application have to speak to the context before we can do anything with\cb1 \
\cb9 our persistent container.So we have to say context dot fetch and the fact that we want to make is our current request which is\cb1 \
\cb9 basically just a blank request that pulls back everything that's currently inside our persistent container.\cb1 \
\cb9 cotext.fetchRequest\
\
and also it throw an error we need to use do and catch block \
And then we fect this requets and collect this in the our array which has our Item(entity) and remember each item which appear in our array and load in each table row is NSMangeObject. \
\cf11 \cb1 \ul \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \kerning1\expnd0\expndtw0 \ulnone do\cf5  \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5           \cf14 itemArray\cf5  = \cf3 try\cf5  \cf14 context\cf5 .\cf15 fetch\cf5 (request)
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \} \cf3 catch\cf5  \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5             \cf15 print\cf5 (\cf7 "There is an error in fetchin request\cf5 \\\cf7 (\cf5 error\cf7 )"\cf5 )
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \}
\f2\fs30 \cf11 \cb1 \expnd0\expndtw0\kerning0
\ul \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf11 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 \kerning1\expnd0\expndtw0 \ulnone \
 \
IN Lesson How to go to list back\
we are serch bar and done with seraching item and want to go back to original list\
1) we will use searchBar delegate method \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\b0\fs34 \cf5 \cb4   \cf3 func\cf5  searchBar(\cf3 _\cf5  searchBar: \cf6 UISearchBar\cf5 , textDidChange searchText: \cf12 String\cf5 ) \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 if\cf5  searchBar.\cf12 text\cf5 ?.\cf12 count\cf5  == \cf19 0\cf5  \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5             \cf6 DispatchQueue\cf5 .\cf12 main\cf5 .\cf15 async\cf5  \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5                 searchBar.\cf15 resignFirstResponder\cf5 ()
\f0\fs24 \cf0 \

\f1\fs34 \cf5             \}
\f0\fs24 \cf0 \

\f1\fs34 \cf5             
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \}\
This delegate method only going triggrred when text is change and the text count become 0
\f0\b\fs36 \cf0 \cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 2) how resignFirstresponder to get rid of keybaord \
\
2) Main queue and background queue.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf16 \ul \ulc16 \
Section 28 Lesson 39: How to create relationship graph in the view contoller.
\b \cf0 \ulnone \
1) we added new view Tableview and make it as root view controller and the existing TDolIstViewController  we created 'show segue' from CategoryView  and create a coca touch file tableVIew  name it categaoryViewcontroller and associate it with Category View. \
facts: all the view controller when we create them they automatocally come with Objective C header file but we cant write any code in it , sowe need to create a controller file for them and associate the view controller with it.\
2) we added and add bar button and  We created new IB Action from this add button \
3) Then we change the Navigation tiltle for both View catagory is ToDoey and ToDOList is items, Now our ToListItem View has an arrow arrow pointing toward Todoey.\
4) No we are going to add a new entity but we will use graph view intead of tableview in context name of category is Catagory and add attribute, the name it 'name' and it is an 'optional' and attribute type is a 'string'. \
5)The we created Relatioshion between two entity from Catagory to Item name it 'items and it type of relationship  'many'\
6) we created inverse relationship from 'Item' to 'Category' name given is 'parentCatogory and and type of realationship is one . So now aour entity 'Catagory'can have many 'items', but 'items' will have only one 'Catagory'\
7) No in CategoryViewController we have implement our new entiry so we will import coredata , the we use TableViewDataSource and TableViewDelagte mehods\
\
For Chalange ;\
1) created an object which is array and hold Categories. name categaoryArray = [Categories]\
2) 
\f2\b0\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
The next thing we need to do is we need to grab a reference to the context that we're going to be using in order to create update and destroy our data. 
\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0  \cf3 let\cf5  context = (UIApplication.shared.delegate \cf3 as\cf5 ! \cf6 AppDelegate\cf5 ).persistentContainer.viewContext\
\pard\pardeftab720\sl340\sa210\partightenfactor0

\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
So the context is going to be equal to our UI application and we're going to grab the shared Singleton\cb1  \cb9 app instance and we're going to tap into its delegate property and we're going to downcast this as a\cb1  \cb9 app delegate object and then we're going to tap into our app delegates persistent container variable\cb1  \cf11 \cb9 \ul and then we're going to load up the view context for that persistent container.\cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf8 \ulnone \
\pard\pardeftab720\sl500\sa210\partightenfactor0
\cf11 \cb10 \ul i
\f0\b\fs36 \cf0 \cb1 \kerning1\expnd0\expndtw0 \ulnone 3) set table data source method numbers of row and cellforrow. number of row is equal categoryArry.count\
then for cell for row we created a catogery \
4) Then we create an UIAlertview in 
\f1\b0\fs34 \outl\strokewidth60 \strokec0 addButtonPressed\cf5 \cb4 \outl0\strokewidth0  with Textfield and we created a property called \cf0 \cb1 \outl\strokewidth60 category \cf5 \cb4 \outl0\strokewidth0  which hold categories entity the we store whatever Text User enter in the textfield in \cf0 \cb1 \outl\strokewidth60 name\cf5 \cb4 \outl0\strokewidth0  attribute or property of \cf0 \cb1 \outl\strokewidth60 category\cf5 \cb4 \outl0\strokewidth0 . Then append the \cf0 \cb1 \outl\strokewidth60 categoryArray\cf5 \cb4 \outl0\strokewidth0  with this \cf0 \cb1 \outl\strokewidth60 category\
\cf5 \cb4 \outl0\strokewidth0 Then we reload our table view \
\
5) Then we craeted saveItem method. 
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
So inside our Save categories method I'm going to try and commit our context to persistenet  container\cb1  \cb9 by saying context.save but  this throws Iwill use do and catch block and also relaod TableView
\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0 \
 and add this func in addButtonPressed because when we create something we always want to save it .\
6)reloadCategory Func: so whatever we save in context we need to relaod when we start our app again. we have to make a request to get the data. and request is going to be NSFetch request 
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
That is going to return an array of category items.\cb1  \cb9 And this is going to be equal to a broad request.\cb1  \cb9 So we want to grab all of the category objects.\cb1  \cb9 So we're going to say category dot Fettes request so we get back all that and as manage objects that were created using the category entity.So now we're going to say try context dot fetch and we're going to fetch back all the results that fit and we saved that in our categaryArray.\cb1 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf11 \cb9 \ul our current request\cb1 \
\pard\pardeftab720\sl500\sa210\partightenfactor0
\cf16 \ulnone Lesson Section 18 lecture 241: Solution: of Challange \
Lesson Section 18 lecture 242:Addind The delegate Metahod \cf8 \
Here we implement the code when user click on one of the category and went to ListViewController.\
1) Here we use TableViewDelegate Method "didSelect " . In this method we tell that when user select the row performSeuue with this identifier(the iidentifiesr of segue between Categaory an ToDoLisTController \
2) Then we also make sure that the   coming view controller is prepare for it and if we more then one segue  from present view controll we will use if and else to avoid any error.\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0  \cf3 override\cf5  \cf3 func\cf5  prepare(for segue: \cf6 UIStoryboardSegue\cf5 , sender: \cf3 Any\cf5 ?) \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 let\cf5  destinationVC = segue.\cf12 destination\cf5  \cf3 as\cf5 ! \cf13 ToDoListViewController
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 if\cf5   \cf3 let\cf5  indexPath = \cf12 tableView\cf5 .\cf12 indexPathForSelectedRow\cf5  \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5             destinationVC.\cf14 selectedCategory\cf5  = \cf14 categoryArray\cf5 [indexPath.\cf12 row\cf5 ]
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \}
\f0\fs24 \cf0 \

\f1\fs34 \cf5     \}
\f0\fs24 \cf0 \

\f1\fs34 \cf5     \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf5 we use this in if and else what if indexPath is not selected it mostly never happend but in cas eavoid an error we do that. if indexPath is selected we are going to tap into aproperty called \cf0 \cb1 \outl\strokewidth60 selectedProperty \outl0\strokewidth0 from \outl\strokewidth60 destinationVC \outl0\strokewidth0 and we are going to set ity to \outl\strokewidth60 categoryArray 
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 But we're going to set the selected category to all array of categories at our index path not the one\cb1  \cb9 with the.\cb1  \cb9 But the one that's lower case that we created here.\
This var we have in ListViewController: It is an  optional But once I do set that selected category then that's the time point when I want to load up all the items\cb1  \cb9 that are relevant to this category.\cb1  \cb9 So something that I can do in swift is I can open up a set of brackets after the select category variable\cb1  \cb9 and I can use a special keyword code did set and everything that's between these curly braces is going\cb1  \cb9 to happen as soon as selected category gets set with a value.\cb1  \cb9 This is the perfect place to call load items instead of using it in ViewDidLoad, So that means when we do call loadItem  we're certain that we've already got a value for our selectedCategaory.\cb1 \
\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0  \cf3 var\cf5  selectedCategory : \cf13 Catogries\cf5 ? \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 didSet\cf5 \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5            \cf18 loadItems\cf5 ()
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \}
\f0\fs24 \cf0 \

\f1\fs34 \cf5     \}
\f2\fs30 \cf0 \cb1 \outl\strokewidth60 \
\pard\pardeftab720\sl500\sa210\partightenfactor0
\cf8 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  3) in TODoListView we have set the our item relationship that is parentcategory\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0 newItem.\cf14 parentCatogeries\cf5  = \cf3 self\cf5 .\cf14 selectedCategory
\f2\fs30 \cf8 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl500\sa210\partightenfactor0
\cf8  4) So now when we click in one of row in Categorie Table it take us to table which have table in TODOListView that have some all the list. To avoid this we have to write a query NSPredicate. \cb9 If you think about it we need to figure out how is our To Do List View Controller loading up all theitems in the table view.\cb1 \
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 \cb9 Well the items come from the item array.\cb1  \cb9 Right.\cb1  \cb9 And the item array comes from the load items method which simply fetches all of the N.S. manage objects\cb1  \cf0 \kerning1\expnd0\expndtw0 that belong in the item table item entity.\cf8 \expnd0\expndtw0\kerning0
 \cb9 But in order for us to only load the items that have the Paran category matching the selected category\cb1  \cb9 we need to query our database for it and we need to filter the result.\cb1  \cb9 So we need to basically create a predicate that is a N.S. predicate and initialize it with the format\cb1 \
\cb9 that the parent category of all the items that we want back must have its name property matching the current selected category name.\cb1  \cb9 And then we need to have this predicate to the request request predicate equals predicate.\cb1 \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \kerning1\expnd0\expndtw0 func\cf5  loadItems(with request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 ())\{
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 let\cf5  predicate = \cf6 NSPredicate\cf5 (format: \cf7 "parentCatogeries.name MATCHES %@"\cf5 , (\cf14 selectedCategory\cf5 !.\cf14 name\cf5 !))
\f0\fs24 \cf0 \

\f1\fs34 \cf5         request.\cf12 predicate\cf5  = predicate
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl340\sa210\partightenfactor0
\cf8 But now we have a bit of a problem because if we set the predicate here and we set the predicate property\cb1 \
\cb9 on the request to this new predicate then the ones that we set before say for example in our search\cb1  \cf0 \kerning1\expnd0\expndtw0 bar is not going to be valid anymore and it's going to be overwritten and you can see this if we run \cf8 \cb9 \expnd0\expndtw0\kerning0
So if we hit shopping list we do in fact go into an empty list because we haven't yet created any new\cb1 \
\cb9 items that have the parent category as shopping list.\cb1  \cb9 But if we add a few items and we now try to search these items you can see that our search fails and\cb1  \cb9 all we get are just the same items but now they're sorted in alphabetical order.\cb1  \cb9 And the reason is because when we press the search button we create a request.\cb1 \
\cb9 5) Solve The Two different Predicate Problem\
a) we added another parameter in \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl\strokewidth60 loadItem\cf8 \cb9 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \kerning1\expnd0\expndtw0 func\cf5  loadItems(with request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 (), predicate: \cf6 NSPredicate)\{\
\}\
b) Then we added the parameter in loadItem when we used it in the searchBar \
\cf3 func\cf5  searchBarSearchButtonClicked(\cf3 _\cf5  searchBar: \cf6 UISearchBar\cf5 ) \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 let\cf5  request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 ()
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 let\cf5  predicate = \cf6 NSPredicate\cf5 (format: \cf7 "title CONTAINS[cd] %@"\cf5 , searchBar.\cf12 text\cf5 !)
\f0\fs24 \cf0 \

\f1\fs34 \cf5         
\f0\fs24 \cf0 \

\f1\fs34 \cf5          request.\cf12 sortDescriptors\cf5  = [\cf6 NSSortDescriptor\cf5 (key: \cf7 "title"\cf5 , ascending: \cf3 true\cf5 )]
\f0\fs24 \cf0 \

\f1\fs34 \cf5         
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf18 loadItems\cf5 (with : request, predicate: predicate)\
\
\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf5 c) Then in \cf0 \cb1 \outl\strokewidth60 loadItem \outl0\strokewidth0 we added NSCompoundPredicate 
\f2\fs30 \cf8 \cb9 \expnd0\expndtw0\kerning0
\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0  \cf3 func\cf5  loadItems(with request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 (), predicate: \cf6 NSPredicate\cf5 ?)\{
\f0\fs24 \cf0 \

\f1\fs34 \cf5         
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 let\cf5  categoryPredicate = \cf6 NSPredicate\cf5 (format: \cf7 "parentCatogeries.name Matches %@"\cf5 , (\cf14 selectedCategory\cf5 !.\cf14 name\cf5 !))
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 let\cf5  compoundPredicate = \cf6 NSCompoundPredicate\cf5 (andPredicateWithSubpredicates : [categoryPredicate, predicate!])
\f0\fs24 \cf0 \

\f1\fs34 \cf5         request.\cf12 predicate\cf5  = compoundPredicate
\f2\fs30 \cf11 \cb1 \expnd0\expndtw0\kerning0
\ul \ulc11 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 \ulnone d) then we also made the parameter \outl\strokewidth60 predicate = nil \outl0\strokewidth0 in \outl\strokewidth60 loadItem\
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf3 \cb4 \outl0\strokewidth0 func\cf5  loadItems(with request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 (), predicate: \cf6 NSPredicate\cf5 ? = \cf3 nil\cf5 )\{
\f0\fs24 \cf0 \

\f1\fs34 \cf5 e) we were getting error that preicate is nil so we use optional binding to safly unwraaped it.\
\cf3 func\cf5  loadItems(with request : \cf6 NSFetchRequest\cf5 <\cf13 Item\cf5 > = \cf13 Item\cf5 .\cf18 fetchRequest\cf5 (), predicate: \cf6 NSPredicate\cf5 ? = \cf3 nil\cf5 )\{
\f0\fs24 \cf0 \

\f1\fs34 \cf5         
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 let\cf5  categoryPredicate = \cf6 NSPredicate\cf5 (format: \cf7 "parentCatogeries.name Matches %@"\cf5 , (\cf14 selectedCategory\cf5 !.\cf14 name\cf5 !))
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 if\cf5  \cf3 let\cf5  additionalPredicate = predicate \{
\f0\fs24 \cf0 \

\f1\fs34 \cf5             request.\cf12 predicate\cf5  = \cf6 NSCompoundPredicate\cf5 (andPredicateWithSubpredicates : [categoryPredicate, additionalPredicate])
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \}
\f0\fs24 \cf0 \

\f1\fs34 \cf5         
\f0\fs24 \cf0 \

\f1\fs34 \cf5         request.\cf12 predicate\cf5  = categoryPredicate       \
\
\
\
\
How to create TextField\
       \cf20 // Or you can position UITextField in the center of the view
\f0\fs24 \cf0 \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf20 //      let myTextField = UITextField(frame: CGRect(x: 90, y: 80, width: UIScreen.main.bounds.size.width - 20.0, height: 50))
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        // Set UITextField placeholder text
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        myTextField.placeholder = "Place holder text"
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        // Set text to UItextField
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        myTextField.text = "UITextField example"
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        // Set UITextField border style
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        myTextField.borderStyle = UITextBorderStyle.roundedRect
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        // Set UITextField background colour
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        myTextField.backgroundColor = UIColor.white
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        // Set UITextField text color
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        myTextField.textColor = UIColor.blue
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        // Add UITextField as a subview
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        self.view.addSubview(myTextField)
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //    \}
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //    override func viewWillAppear(_ animated: Bool) \{
\f0\fs24 \cf0 \

\f1\fs34 \cf20 //        navigationController?.navigationBar.frame = CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 80.0)
\f2\fs30 \cf0 \cb1 \
\pard\tx840\pardeftab840\pardirnatural\partightenfactor0

\f1\fs34 \cf5 \cb4  \cf3 self\cf5 .\cf14 textFieldMy\cf5  = \cf6 UITextField\cf5 (frame: \cf12 CGRect\cf5 (x: \cf19 50\cf5 , y: \cf14 navBar\cf5 .\cf12 frame\cf5 .\cf12 height\cf5  , width: \cf19 400\cf5 , height: \cf19 30\cf5 ))
\f0\fs24 \cf0 \

\f1\fs34 \cf5        \cf3 self\cf5 .\cf14 textFieldMy\cf5 .\cf12 translatesAutoresizingMaskIntoConstraints\cf5  = \cf3 true
\f0\fs24 \cf0 \

\f1\fs34 \cf5       \cf3 self\cf5 .\cf14 textFieldMy\cf5 .\cf12 backgroundColor\cf5  = \cf6 UIColor\cf5 .\cf14 flatWhiteDark
\f0\fs24 \cf0 \

\f1\fs34 \cf5       \cf3 self\cf5 .\cf14 textFieldMy\cf5 .\cf12 tintColor\cf5  = \cf6 UIColor\cf5 .\cf12 black
\f0\fs24 \cf0 \

\f1\fs34 \cf5       \cf3 self\cf5 .\cf14 textFieldMy\cf5 .\cf12 text\cf5  = \cf7 "label text"
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 self\cf5 .\cf14 textFieldMy\cf5 .\cf12 layer\cf5 .\cf12 cornerRadius\cf5  = \cf19 4.0
\f0\fs24 \cf0 \

\f1\fs34 \cf5        
\f0\fs24 \cf0 \

\f1\fs34 \cf5      \cf3 self\cf5 .\cf14 textFieldMy\cf5 .\cf12 layer\cf5 .\cf12 borderWidth\cf5  = \cf19 1
\f0\fs24 \cf0 \

\f1\fs34 \cf5         \cf3 self\cf5 .\cf12 view\cf5 .\cf15 addSubview\cf5 (\cf3 self\cf5 .\cf14 textFieldMy\cf5 )
\f0\fs24 \cf0 \
\pard\pardeftab720\sl500\sa210\partightenfactor0

\f2\fs30 \cf8 \cb1 \expnd0\expndtw0\kerning0
\

\f1\fs34 \cf5 \cb4 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\sl500\sa210\partightenfactor0

\f0\b\fs36 \cf0 \cb1 \
}